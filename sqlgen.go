package gosqlgen

import (
	"bytes"
	"go/format"
	"io"
	"maps"
	"os"
	"slices"
)

type Driver interface {
	Get(w io.Writer, table *Table, keys []*Column, methodName string) error
	Create(w io.Writer, table *Table, methodName string) error
	Update(w io.Writer, table *Table, keys []*Column, methodName string) error
	Delete(w io.Writer, table *Table, keys []*Column, methodName string) error
}

type MethodName string

const (
	MethodGetByPrimaryKeys     MethodName = "getByPrimaryKeys"
	MethodGetByBusinessKeys    MethodName = "getByBusinessKeys"
	MethodInsert               MethodName = "insert"
	MethodUpdateByPrimaryKeys  MethodName = "updateByPrimaryKeys"
	MethodUpdateByBusinessKeys MethodName = "updateByBusinessKeys"
	MethodDelete               MethodName = "delete"
)

func additionalImports(model *DBModel) ([]string, []string, error) {
	codeImports := []string{}
	testCodeImports := []string{}
	testCodeImportsMap := make(map[string]bool)
	for _, table := range model.Tables {
		if table.HasFlag(TableFlagIgnoreTest) || table.HasFlag(TableFlagIgnore) {
			continue
		}

		for _, column := range table.Columns {
			_, isTime := column.format.IsTime()
			if IsOneOfTypes(column.Type, TimeTypesAll) || isTime {
				testCodeImportsMap["time"] = true
			}
		}
	}

	if len(testCodeImportsMap) > 0 {
		testCodeImports = slices.Collect(maps.Keys(testCodeImportsMap))
	}

	return codeImports, testCodeImports, nil
}

type TestSuite interface {
	GetInsert(w io.Writer, table *Table) error
	Update(w io.Writer, table *Table) error
	Delete(w io.Writer, table *Table) error
	ExecuteTemplate(w io.Writer, tmpl string, data any) error
}

// CreateTemplates constructs generated code and test code from the given DBModel.
// The resulting code is formatted
func CreateTemplates(d Driver, model *DBModel, ts TestSuite, outputPath, outputTestPath string) error {
	writer := new(bytes.Buffer)
	testWriter := new(bytes.Buffer)

	header := `// Generated by: github.com/tsladecek/gosqlgen`

	codeImports, testCodeImports, err := additionalImports(model)
	if err != nil {
		return Errorf("when inferring additional imports: %w", err)
	}

	methodsData := make(map[string]any)
	methodsData["Package"] = model.PackageName
	methodsData["Header"] = header
	methodsData["Imports"] = codeImports
	err = ts.ExecuteTemplate(writer, "methodsHeader", methodsData)
	if err != nil {
		return Errorf("when executing code header template: %w", err)
	}

	testData := make(map[string]any)
	testData["Package"] = model.PackageName
	testData["Header"] = header
	testData["Imports"] = testCodeImports
	err = ts.ExecuteTemplate(testWriter, "testHeader", testData)
	if err != nil {
		return Errorf("when executing test code header template: %w", err)
	}

	for _, table := range model.Tables {
		if table.HasFlag(TableFlagIgnore) {
			continue
		}

		// GET
		pk, bk, err := table.primaryKeysAndBusinessKeys()
		if err != nil {
			return Errorf("when fetching primary and business keys for table %s: %w", table.Name, err)
		}
		err = d.Get(writer, table, pk, string(MethodGetByPrimaryKeys))
		if err != nil {
			return Errorf("when creating GET template by primary keys for table %s: %w: %w", table.Name, err)
		}

		if len(bk) > 0 {
			err = d.Get(writer, table, bk, string(MethodGetByBusinessKeys))
			if err != nil {
				return Errorf("when creating GET template by business keys for table %s: %w: %w", table.Name, err)
			}
		}

		// CREATE
		err = d.Create(writer, table, string(MethodInsert))
		if err != nil {
			return Errorf("when creating insert template for table %s: %w: %w", table.Name, err)
		}

		// UPDATE
		if !table.HasFlag(TableFlagIgnoreUpdate) {
			err = d.Update(writer, table, pk, string(MethodUpdateByPrimaryKeys))
			if err != nil {
				return Errorf("when creating update template for table %s by primary keys: %w: %w", table.Name, err)
			}
			if len(bk) > 0 {
				err = d.Update(writer, table, bk, string(MethodUpdateByBusinessKeys))
				if err != nil {
					return Errorf("when creating update template for table %s by business keys: %w: %w", table.Name, err)
				}
			}
		}

		// DELETE
		if !table.HasFlag(TableFlagIgnoreDelete) {
			err = d.Delete(writer, table, pk, string(MethodDelete))
			if err != nil {
				return Errorf("when creating delete template for table %s by primary keys: %w: %w", table.Name, err)
			}

		}

		// Generate tests
		if !table.HasFlag(TableFlagIgnoreTest) {
			err = GenerateTests(ts, testWriter, table)
			if err != nil {
				return Errorf("when creating test template for table %s: %w: %w", table.Name, err)
			}
		}
	}

	code, err := format.Source(writer.Bytes())
	if err != nil {
		return Errorf("when formating code: %w", err)
	}

	testCode, err := format.Source(testWriter.Bytes())
	if err != nil {
		return Errorf("when formating test code: %w", err)
	}

	err = os.WriteFile(outputPath, code, 0666)
	if err != nil {
		return Errorf("when writing code to a file: %w", err)
	}

	err = os.WriteFile(outputTestPath, testCode, 0666)
	if err != nil {
		return Errorf("when writing test code to a file: %w", err)
	}

	return nil
}
